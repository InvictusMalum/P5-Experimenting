<!DOCTYPE html>
<html>

<head>
    <title>Flow Field</title>
</head>

<body>
    <script src="p5.js"></script>
    <script src="sketch.js"></script>
    <script id="velocity_worker" type="javascript/worker">
        function abs(value) {
            if (value >= 0) {
                return value
            } else {
                return -1*value;
            }
        }

        function angleFromXY(x, y) {
            if (x == 0) {
                if (y >= 0) {
                    return PI / 2;
                } else {
                    return 3 * PI / 2;
                }
            }

            theta = (Math.atan(y / x)) + 2 * PI;
            if (x < 0) {
                theta += PI;
            }
            return theta % (2*PI);
        }

        self.onmessage = function(e) {
            [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before, backwards_traversal, random, addition_values] = e.data.args;
            curves = [];

            PI = 3.141593;

            initial_velocity = random*2*PI;

            for (var i=0; i<x_list.length; i++) {
                x = x_list[i];
                y = y_list[i];
                velocity = initial_velocity;
                
                step_length = step_length_list[i];
                num_steps = num_steps_list[i];
                
                grid_angle = null;

                points = [];
                for (let n=0; n<num_steps; n++) {
                    x_offset = x - left_x;
                    y_offset = y - top_y;
                    column_index = Math.floor(x_offset / resolution);
                    row_index = Math.floor(y_offset / resolution);
                    points.push({'x' : x, 'y' : y});
                    if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                        if (grid_angle == null) {
                            grid_angle = grid[row_index][column_index];
                        }
                        grid_angle = grid[row_index][column_index];

                        velocity = angleFromXY(Math.cos(velocity)+addition_values[0]*Math.cos(grid_angle), Math.sin(velocity)+addition_values[0]*Math.sin(grid_angle))

                        x_step = step_length * Math.cos(velocity);
                        y_step = step_length * Math.sin(velocity);
                        x += x_step;
                        y += y_step;
                    } else {
                        break;
                    }
                }

                if (backwards_traversal) {
                    x = x_list[i];
                    y = y_list[i];
                    velocity = initial_velocity + PI;

                    grid_angle = null;
                    
                    for (let n=0; n<num_steps; n++) {
                        x_offset = x - left_x;
                        y_offset = y - top_y;
                        column_index = Math.floor(x_offset / resolution);
                        row_index = Math.floor(y_offset / resolution);
                        if (n>0) {
                            points.unshift({'x' : x, 'y' : y});
                        }
                        if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                            if (grid_angle == null) {
                                grid_angle = ((grid[row_index][column_index] + PI)%(PI*2));
                            }
                            grid_angle = grid[row_index][column_index];

                            velocity = angleFromXY(Math.cos(velocity)+addition_values[0]*Math.cos(grid_angle), Math.sin(velocity)+addition_values[0]*Math.sin(grid_angle))

                            x_step = step_length * Math.cos(velocity);
                            y_step = step_length * Math.sin(velocity);
                            x += x_step;
                            y += y_step;
                        } else {
                            break;
                        }
                    }
                }
                curves.push(points);
            }
            self.postMessage({"curves" : curves, "curves_made_before" : curves_made_before});
        };
    </script>
    <script id="turning_worker" type="javascript/worker">
        function abs(value) {
            if (value >= 0) {
                return value
            } else {
                return -1*value;
            }
        }

        self.onmessage = function(e) {
            [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before, backwards_traversal, random, addition_values] = e.data.args;
            curves = [];

            PI = 3.141593;

            initial_angle = random*2*PI;

            for (var i=0; i<x_list.length; i++) {
                x = x_list[i];
                y = y_list[i];
                angle = initial_angle;
                
                step_length = step_length_list[i];
                num_steps = num_steps_list[i];
                
                grid_angle = null;

                points = [];
                for (let n=0; n<num_steps; n++) {
                    x_offset = x - left_x;
                    y_offset = y - top_y;
                    column_index = Math.floor(x_offset / resolution);
                    row_index = Math.floor(y_offset / resolution);
                    points.push({'x' : x, 'y' : y});
                    if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                        if (grid_angle == null) {
                            grid_angle = grid[row_index][column_index];
                        }
                        grid_angle = grid[row_index][column_index];
                        
                        angle = (angle+addition_values[0]*grid_angle) % (2*PI);
                        
                        x_step = step_length * Math.cos(angle);
                        y_step = step_length * Math.sin(angle);
                        x += x_step;
                        y += y_step;
                    } else {
                        break;
                    }
                }

                if (backwards_traversal) {
                    x = x_list[i];
                    y = y_list[i];
                    angle = initial_angle + PI;

                    grid_angle = null;
                    
                    for (let n=0; n<num_steps; n++) {
                        x_offset = x - left_x;
                        y_offset = y - top_y;
                        column_index = Math.floor(x_offset / resolution);
                        row_index = Math.floor(y_offset / resolution);
                        if (n>0) {
                            points.unshift({'x' : x, 'y' : y});
                        }
                        if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                            if (grid_angle == null) {
                                grid_angle = ((grid[row_index][column_index] + PI)%(PI*2));
                            }
                            grid_angle = grid[row_index][column_index];
                            
                            angle = (angle+addition_values[0]*grid_angle) % (2*PI);

                            x_step = step_length * Math.cos(angle);
                            y_step = step_length * Math.sin(angle);
                            x += x_step;
                            y += y_step;
                        } else {
                            break;
                        }
                    }
                }
                curves.push(points);
            }
            self.postMessage({"curves" : curves, "curves_made_before" : curves_made_before});
        };
    </script>
    <script id="spiral_worker" type="javascript/worker">
        function abs(value) {
            if (value >= 0) {
                return value
            } else {
                return -1*value;
            }
        }

        function angleFromXY(x, y) {
            if (x == 0) {
                if (y >= 0) {
                    return PI / 2;
                } else {
                    return 3 * PI / 2;
                }
            }

            var theta = (Math.atan(y / x)) + 2 * PI;
            if (x < 0) {
                theta += PI;
            }
            return theta % (2*PI);
        }

        self.onmessage = function(e) {
            [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before, backwards_traversal, random, addition_values] = e.data.args;
            curves = [];

            PI = 3.141593;

            initial_angle = random*2*PI;
            
            addition_per_step = addition_values[0]+(random*100)%1*(addition_values[1] - addition_values[0]);
            grid_weight = addition_values[2]+(random*10000)%1*(addition_values[3] - addition_values[2]);

            for (var i=0; i<x_list.length; i++) {
                x = x_list[i];
                y = y_list[i];
                angle = initial_angle;

                step_length = step_length_list[i];
                num_steps = num_steps_list[i];
                
                grid_angle = null;

                points = [];
                for (let n=0; n<num_steps; n++) {
                    x_offset = x - left_x;
                    y_offset = y - top_y;
                    column_index = Math.floor(x_offset / resolution);
                    row_index = Math.floor(y_offset / resolution);
                    points.push({'x' : x, 'y' : y});
                    if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                        if (grid_angle == null) {
                            grid_angle = grid[row_index][column_index];
                        }
                        grid_angle = grid[row_index][column_index];
                        
                        angle = (angle+addition_per_step) % (2*PI);

                        function_angle = angleFromXY(Math.cos(angle)+grid_weight*Math.cos(grid_angle), Math.sin(angle)+grid_weight*Math.sin(grid_angle))
                        

                        x_step = step_length * Math.cos(function_angle);
                        y_step = step_length * Math.sin(function_angle);
                        x += x_step;
                        y += y_step;
                    } else {
                        break;
                    }
                }

                if (backwards_traversal) {
                    x = x_list[i];
                    y = y_list[i];
                    angle = initial_angle;

                    grid_angle = null;
                    
                    for (let n=0; n<num_steps; n++) {
                        x_offset = x - left_x;
                        y_offset = y - top_y;
                        column_index = Math.floor(x_offset / resolution);
                        row_index = Math.floor(y_offset / resolution);
                        if (n>0) {
                            points.unshift({'x' : x, 'y' : y});
                        }
                        if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                            if (grid_angle == null) {
                                grid_angle = ((grid[row_index][column_index] + PI)%(PI*2));
                            }
                            grid_angle = grid[row_index][column_index];
                            
                            angle = (angle-addition_per_step) % (2*PI);

                            function_angle = angleFromXY(Math.cos(angle)+grid_weight*Math.cos(grid_angle), Math.sin(angle)+grid_weight*Math.sin(grid_angle))


                            x_step = step_length * Math.cos(function_angle + PI);
                            y_step = step_length * Math.sin(function_angle + PI);
                            x += x_step;
                            y += y_step;
                        } else {
                            break;
                        }
                    }
                }
                curves.push(points);
            }
            self.postMessage({"curves" : curves, "curves_made_before" : curves_made_before});
        };
    </script>
    <script id="multi_curve_worker" type="javascript/worker">
        function abs(value) {
            if (value >= 0) {
                return value
            } else {
                return -1*value;
            }
        }

        self.onmessage = function(e) {
            [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before, backwards_traversal] = e.data.args;
            curves = [];

            PI = 3.141593;

            for (var i=0; i<x_list.length; i++) {
                x = x_list[i];
                y = y_list[i];
                step_length = step_length_list[i];
                num_steps = num_steps_list[i];
                
                grid_angle = null;

                points = [];
                for (let n=0; n<num_steps; n++) {
                    x_offset = x - left_x;
                    y_offset = y - top_y;
                    column_index = Math.floor(x_offset / resolution);
                    row_index = Math.floor(y_offset / resolution);
                    points.push({'x' : x, 'y' : y});
                    if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                        if (grid_angle == null) {
                            grid_angle = grid[row_index][column_index];
                        }
                        else if (abs(grid_angle-grid[row_index][column_index]) > PI/2+.001 && abs(grid_angle-grid[row_index][column_index]) < 3*PI/2-.001) {
                            grid_angle = (grid[row_index][column_index] + PI) % (PI*2);
                        } else {
                            grid_angle = grid[row_index][column_index];
                        }
                        x_step = step_length * Math.cos(grid_angle);
                        y_step = step_length * Math.sin(grid_angle);
                        x += x_step;
                        y += y_step;
                    } else {
                        break;
                    }
                }

                if (backwards_traversal) {
                    x = x_list[i];
                    y = y_list[i];

                    grid_angle = null;
                    
                    for (let n=0; n<num_steps; n++) {
                        x_offset = x - left_x;
                        y_offset = y - top_y;
                        column_index = Math.floor(x_offset / resolution);
                        row_index = Math.floor(y_offset / resolution);
                        if (n>0) {
                            points.unshift({'x' : x, 'y' : y});
                        }
                        if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows && grid[row_index][column_index] != null) {
                            if (grid_angle == null) {
                                grid_angle = ((grid[row_index][column_index] + PI)%(PI*2));
                            }
                            else if (abs(grid_angle-((grid[row_index][column_index] + PI)%(PI*2))) > PI/2+.001 && abs(grid_angle-((grid[row_index][column_index] + PI)%(PI*2))) < 3*PI/2-.001) {
                                grid_angle = grid[row_index][column_index];
                            } else {
                                grid_angle = (grid[row_index][column_index] + PI) % (PI*2);
                            }
                            x_step = step_length * Math.cos(grid_angle);
                            y_step = step_length * Math.sin(grid_angle);
                            x += x_step;
                            y += y_step;
                        } else {
                            break;
                        }
                    }
                }
                curves.push(points);
            }
            self.postMessage({"curves" : curves, "curves_made_before" : curves_made_before});
        };
    </script>
    <script type="text/javascript">
        class Template {
            static Perlin = new Template("perlin")
            static Circles = new Template("circles")
            static Squares = new Template("squares")
            static Spirals = new Template("spirals")
            static Cardioids = new Template("cardioids")
            static Roses = new Template("roses")

            static Normal = new Template("normal")
            static Velocity = new Template("velocity")
            static Turning = new Template("turning")

            static Slinkies = new Template("slinkies")

            constructor(name) {
                this.name = name;
            }

            // Given row and column, return an angle. theta_offset will rotate the entire grid by a value, a is a number needed for certain shapes (number of petals, etc)
            static getAngle = function(row, col, a, theta_offset) {
                // Where center is (0,0)
                var x = (col - num_columns / 2);
                var y = (row - num_rows / 2);

                // Processing's noise() works best when the step between
                // points is approximately 0.005, so scale down to that
                var scaled_x = col * .005
                var scaled_y = row * .005
                // translate the noise value to an angle (betwen 0 and 2 * PI)
                // 3rd argument increases complexity as it gets smaller? Default to 1
                var angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2*PI);
                //angle = roundAngleTo(angle, PI/6);
                
                
                //var angle = PI;

                // Polar Coordinates -------------------------
                var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));
                

                // // Can create some cool effects
                // theta *= r/100;

                

                // angle = theta + PI;
                
                // // Concentric Circles
                // angle = theta + PI / 2;

                // // Add to Circles for Concentric Rectangles
                // angle = roundAngleTo(angle, PI/2);

                // // Flower, where a-2 is the number of petals
                // // a is defined randomly above
                // a = 9;
                // angle = a/2*theta;

                // // Spiralish
                // angle = angleFromXY(1,(Math.tan(theta)+theta)/(1-theta*Math.tan(theta)))

                // angle = (x<0 && y<0) ? -2*theta/2 : -2*theta/2;

                // a = 20;
                // angle = (Math.acos((dist-a)/a)+PI/1) % (2*PI);


                // // Pulls lines in to center
                // // Add this to circles for cool spirals
                // h_pull_power = 1;
                // v_pull_power = 1/8*h_pull_power;
                // vector_pull = [Math.cos(angle) - h_pull_power * Math.cos(theta), Math.sin(angle) - v_pull_power * Math.sin(theta)]
                // angle = angleFromXY(vector_pull[0], vector_pull[1]);
                
                // // ROSES
                // // s defines petal stretch
                // // 2a defines petal number 
                // s = 1
                // a = 1
                // angle = Math.atan((a*Math.cos(a*theta)*Math.sin(theta)+Math.sin(a*theta)*Math.cos(theta))/(a*Math.cos(a*theta)*Math.cos(theta)-Math.sin(a*theta)*Math.sin(theta)))

                // // LOGARITHMIC SPIRAL
                // // smaller b = more spiraling
                // b = .5;
                // angle = Math.atan((Math.tan(theta)+1/b)/(1-Math.tan(theta)/b))
                
                return (angle + theta_offset) % (2 * PI);
            }

            runFunction(args) {
                switch (this.name) {
                    case "perlin":
                        this.perlin(args);
                        break;
                    case "circles":
                        this.circles(args);
                        break;
                    case "squares":
                        this.squares(args);
                        break;
                    case "spirals":
                        this.spirals(args);
                        break;
                    case "cardioids":
                        this.cardioids(args);
                        break;
                    case "roses":
                        this.roses(args);
                        break;
                    case "normal":
                        this.normal(args);
                        break;
                    case "velocity":
                        this.velocity(args);
                        break;
                    case "turning":
                        this.turning(args);
                        break;
                    case "slinkies":
                        this.slinkies(args);
                        break;
                    default:
                        break;

                }
            }

            perlin(args) {
                collision_removal = false;
                min_length = 100;
                stroke_spacing = 0;

                backwards_traversal = true;
                self_collision_removal = false;
                center_destruction = false;

                curve_type_index = 0;                

                //background_color = null;
                total_curves = 4000;

                min_thickness = 2;
                max_thickness = 2;

                length_of_step = .5;
                step_min = 100;
                step_max = 150;
                
                Template.getAngle = function(row, col, a, theta_offset) {
                    //return (default_angle + theta_offset)
                    
                    // Processing's noise() works best when the step between
                    // points is approximately 0.005, so scale down to that
                    var scaled_x = col * .005
                    var scaled_y = row * .005
                    // translate the noise value to an angle (betwen 0 and 2 * PI)
                    // 3rd argument increases complexity as it gets smaller? Default to 1
                    var angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2*PI);

                    //angle = roundAngleTo(angle, PI/6);

                    return (angle + theta_offset) % (2 * PI);
                }
            }

            circles(args) {
                Template.getAngle = function(row, col, a, theta_offset) {
                    // Polar Coordinates -------------------------
                    var x = (col - num_columns / 2);
                    var y = (row - num_rows / 2);
                    var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                    var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));
                
                    var angle = theta + PI / 2;

                    return (angle + theta_offset) % (2 * PI);
                }
            }
            
            squares(args) {
                Template.getAngle = function(row, col, a, theta_offset) {
                    // Polar Coordinates -------------------------
                    var x = (col - num_columns / 2);
                    var y = (row - num_rows / 2);
                    var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                    var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));
                
                    var angle = theta + PI / 2;
                    angle = roundAngleTo(angle, PI/2);

                    return (angle + theta_offset) % (2 * PI);
                }
            }

            spirals(args) {
                Template.getAngle = function(row, col, a, theta_offset) {
                    // Polar Coordinates -------------------------
                    var x = (col - num_columns / 2);
                    var y = (row - num_rows / 2);
                    var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                    var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));
                
                    var angle = theta + PI / 2;

                    var h_pull_power = 1;
                    var v_pull_power = 1/8*h_pull_power;
                    var vector_pull = [Math.cos(angle) - h_pull_power * Math.cos(theta), Math.sin(angle) - v_pull_power * Math.sin(theta)]
                    angle = angleFromXY(vector_pull[0], vector_pull[1]);

                    return (angle + theta_offset) % (2 * PI);
                }
            }

            cardioids(args) {
                Template.getAngle = function(row, col, a, theta_offset) {    
                    // Polar Coordinates -------------------------
                    var x = (col - num_columns / 2);
                    var y = (row - num_rows / 2);
                    var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                    var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));

                    // Flower, where a-2 is the number of petals
                    // a is defined randomly above
                    a = 9;
                    var angle = a/2*theta;

                    return (angle + theta_offset) % (2 * PI);
                }
            }

            roses(args) {
                Template.getAngle = function(row, col, a, theta_offset) {    
                    // Polar Coordinates -------------------------
                    var x = (col - num_columns / 2);
                    var y = (row - num_rows / 2);
                    var theta = (angleFromXY(x, y) - theta_offset) % (2*PI);
                    var r = sqrt(Math.pow((row - num_rows / 2), 2) + Math.pow((col - num_columns / 2), 2));

                    // ROSES
                    // s defines petal stretch
                    // 2a defines petal number 
                    var s = 1
                    a = 1
                    angle = Math.atan((a*Math.cos(a*theta)*Math.sin(theta)+Math.sin(a*theta)*Math.cos(theta))/(a*Math.cos(a*theta)*Math.cos(theta)-Math.sin(a*theta)*Math.sin(theta)))


                    return (angle + theta_offset) % (2 * PI);
                }
            }

            normal(args) {
                curve_type_index = 0;
            }

            velocity(args) {
                curve_type_index = 1;
            }

            turning(args) {
                Template.getAngle = function(row, col, a, theta_offset) {
                    // Processing's noise() works best when the step between
                    // points is approximately 0.005, so scale down to that
                    var scaled_x = col * .005
                    var scaled_y = row * .005
                    // translate the noise value to an angle (betwen 0 and 2 * PI)
                    // 3rd argument increases complexity as it gets smaller? Default to 1
                    var angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2*PI);

                    return (angle + theta_offset) % (2 * PI);
                }
                curve_type_index = 2;
            }

            slinkies(args) {
                // In this case, addition_values is a list of how fast
                addition_values = [PI/16, PI/8, 2, 3];
                stroke_spacing = 4;

                backwards_traversal = true;
                self_collision_removal = false;
                center_destruction = false;

                collision_removal = false;
                min_length = 100;
                
                
                Template.getAngle = function(row, col, a, theta_offset) {
                    //return (default_angle + theta_offset)
                    
                    // Processing's noise() works best when the step between
                    // points is approximately 0.005, so scale down to that
                    var scaled_x = col * .005
                    var scaled_y = row * .005
                    // translate the noise value to an angle (betwen 0 and 2 * PI)
                    // 3rd argument increases complexity as it gets smaller? Default to 1
                    var angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2*PI);

                    //angle = roundAngleTo(angle, PI/6);

                    return (angle + theta_offset) % (2 * PI);
                }

                curve_type_index = 3;                

                //background_color = null;
                total_curves = 100;

                min_thickness = 3;
                max_thickness = 6;

                length_of_step = 4;
                step_min = 1000;
                step_max = 1500;
            }
        }

        var drawings_made = 0;
        var total_drawings = 1;
        var save_and_restart = true;

        var save_data = true;
        var drawing_data = [];

        var template = Template.Perlin;


        // STEPS -------------------------------------------------------------------------------------------------
            // Define Grid
            // Place curves
                // Position
                // Number of curves
            // Curves Respond to Grid
                // Turning
                // Responses to other curves
            // Drawing/Style
                // Length
                // Width
                // Color

        // HOW CURVES RESPOND TO GRID ----------------------------------------------------------------------------
            // Specifies how a curve responds to the angles of the grid
                var curve_types = ['#multi_curve_worker','#velocity_worker', '#turning_worker', '#spiral_worker']
                var curve_type_index = 0;
                // For velocity and turning workers
                var addition_values = [.05];

            // Settings for early curve termination
                var backwards_traversal = false;    
            
                var collision_removal = true;
                var same_color_allowed = false;
                var self_collision_removal = true; // WIP

                var center_destruction = true;
                var distance_to_center = 5;
                

                // Drawn map is an array where each curve draws its own ID onto the grid
                var drawn_map;
                // Color map is an array where each curve draws its own COLOR onto the grid
                var color_map;
                // Ensures that curves aren't drawn if they are killed while still too short
                var min_length = 20;

        
        // STYLE -------------------------------------------------------------------------------------------------
            // Width of lines
                var min_thickness = 1;
                var max_thickness = 2;
            // Invisible extra width for adding space between lines
                var stroke_spacing = 0;


            // Number of total threads to calculate curves (lower this number if the page runs out of data)
                var total_workers = 800;
            // Number of total curves
                var total_curves = 4000;
            // Counts sucessful drawings
                var workers_complete;
            // Length of each step
                var length_of_step = .5;
            // Range for number of steps per curve
                var step_min = 250;
                var step_max = 350;

            // Will fill with colors in the color palette
                var chosen_colors;


            var background_color = null;
            


        // DEFINING GRID -----------------------------------------------------------------------------------------
            // Max and min X and Y values
                var left_x;
                var right_x;
                var top_y;
                var bottom_y;

            // Extra space outside the drawn screen to make curves go past the image borders
                var decimal_overhang = .1;

            // Converting screen coordinates to coordiantes in a smaller array
                var resolution;
                var num_columns;
                var num_rows;
                var grid;

            var default_angle = 0;

            var getAngle;
            var a;

        function setup() {
            background_color = new Color(0,0,0);
            template.runFunction([]);
            
            // P5.JS SETUP ---------------------------------------------------------
            createCanvas(800, 800);
            colorMode(HSL, 360);
            setupCustom();
        }

        function setupCustom() {
            // GENERATE COLORS -----------------------------------------------------
            chosen_colors = [];
            setChosenColors(3, 2, 2, 2, 3, 3);

            if (background_color == null) {
                background_color = new Color(chosen_colors[0].hue,chosen_colors[0].saturation,chosen_colors[0].lightness);
            }

            workers_complete = 0;
            noiseSeed(Math.floor(lerp(0,100000, random())));


            // DEFINING SCREEN BOUNDARIES ------------------------------------------
            left_x = Math.floor(width * -(decimal_overhang));
            right_x = Math.floor(width * (1 + (decimal_overhang)));
            top_y = Math.floor(height * -(decimal_overhang));
            bottom_y = Math.floor(height * (1 + (decimal_overhang)));

            // CREATING MAPS FOR DETECTING COLLISIONS ------------------------------
            drawn_map = [];
            for (let row = 0; row < Math.floor(bottom_y - top_y); row++) {
                var row_list = [];
                for (let col = 0; col < Math.floor(right_x - left_x); col++) {
                    row_list.push(0);
                }
                drawn_map.push(row_list);
            }

            color_map = [];
            for (let row = 0; row < Math.floor(bottom_y - top_y); row++) {
                var row_list = [];
                for (let col = 0; col < Math.floor(right_x - left_x); col++) {
                    row_list.push(0);
                }
                color_map.push(row_list);
            }

            // CREATING ANGLE GRID -------------------------------------------------
            resolution = Math.floor(width * 0.005);
            num_columns = (right_x - left_x) / resolution;
            num_rows = (bottom_y - top_y) / resolution;
            grid = [];
            for (let i = 0; i < num_columns; i++) {
                grid.push([]);
            }

            // Fill with angles
            theta_offset = random()*2*PI
            a = Math.floor(lerp(1, 15, random()));
            for (let row = 0; row < num_rows; row++) {
                for (let col = 0; col < num_columns; col++) {
                    grid[row][col] = Template.getAngle(row, col, a, theta_offset);
                }
            }
        }

        function draw() {
            background(background_color.hue, background_color.saturation, background_color.lightness);
            noFill();
            noLoop();

            var curves_made = 0;
            var curves_made_before = 0;

            curve_per_worker = int(total_curves / total_workers);
            for (let i = 0; i < min(total_workers, total_curves); i += 1) {
                w = getWorker();
                curves_for_this_worker = curve_per_worker;
                if (i < total_curves % total_workers) {
                    curves_for_this_worker++;
                }

                x_list = [];
                y_list = [];
                step_length_list = [];
                num_steps_list = [];
                for (let j = 0; j < curves_for_this_worker; j += 1) {
                    [x,y] = randomCoordinates();
                    //[x, y] = getStartCoordinates(curves_made, total_curves);
                    //[x, y] = findWhiteSpace(1, 1000);

                    x_list.push(x);
                    y_list.push(y);

                    var step_length = length_of_step;
                    step_length_list.push(step_length);
                    var num_steps = Math.floor(lerp(step_min, step_max, random()));
                    num_steps_list.push(num_steps);
                    curves_made += 1;
                }
                w.postMessage( { "args": [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made - curves_for_this_worker, backwards_traversal, random(), addition_values] } );
            }
        }

        // HSL color storage
        class Color {
            constructor(H, S, L) {
                this.hue = Math.floor(H);
                this.saturation = Math.floor(S);
                this.lightness = Math.floor(L);
            }

            get values() {
                return [this.hue, this.saturation, this.lightness]
            }
        }

        // A list of the same color with varying lightness
        class MonochromaticSet {
            constructor(lDiff, lMin, lMax, startingColor = new Color(random() * 360, random() * 100 + 260, 100)) {
                this.colors = [];

                this.startingColor = startingColor;
                this.lDiff = lDiff;
                this.lMin = lMin;
                this.lMax = lMax;

                let hue = startingColor.hue;
                let sat = startingColor.saturation;
                let startL = (startingColor.lightness - lMin) % lDiff + lMin;
                for (let L = startL; L < lMax; L += lDiff) {
                    this.colors.push(new Color(hue, sat, L));
                }
            }

            // Makes another MonochromaticSet with a slightly different hue
            createSecondary(lDiff = this.lDiff, lMin = this.lMin, lMax = this.lMax, hOff = 30) {
                return new MonochromaticSet(lDiff, lMin, lMax, new Color((this.startingColor.hue + hOff) % 360, this.startingColor.saturation, this.startingColor.lightness));
            }
        }

        // Generates color palette
        function setChosenColors(sets = 2, min_off_set = 1, max_off_set = 3, colors_per_set = 3, min_off_color = 3, max_off_color = 5) {
            var colors = [];

            colors.push(new MonochromaticSet(12, 0, 360))
            for (let i = 0; i < 11; i++) {
                colors.push(colors[colors.length - 1].createSecondary())
            }

            var color_offs = [];
            for (let set = 0; set < sets; set++) {
                color_offs.push(Math.floor(lerp(min_off_color, max_off_color + 1, random())));
            }


            var set_index = 2;
            for (let set = 0; set < sets; set++) {
                var color_index = 8;
                for (let color = 0; color < colors_per_set; color++) {
                    chosen_colors.push(colors[set_index].colors[color_index]);
                    color_index += color_offs[set];
                    color_index %= colors[set_index].colors.length;
                }
                set_index += Math.floor(lerp(min_off_set, max_off_set + 1, random()));
                set_index %= colors.length;
            }
        }

        // Rounds an ANGLE to the closest multiple of MULTIPLE 
        function roundAngleTo(angle, multiple) {
            return round(angle / multiple) * multiple;
        }

        // Checks a radius around position (X,Y) in the MAP and sees if there are any values other than 0 and an IGNORED value
        function checkProximity(x, y, radius, ignored, map=drawn_map) {
            for (let x_off = -radius; x_off <= radius; x_off++) {
                for (let y_off = -radius; y_off <= radius; y_off++) {
                    if (y + y_off >= 0 && y + y_off < map.length && x + x_off >= 0 && x + x_off < map[0].length) {
                        if (map[y + y_off][x + x_off] != 0 && map[y + y_off][x + x_off] != ignored) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Check if the X and Y postion is within specified RADIUS of the center (CENTER_X, CENTER_Y)
        function checkCenterCollision(x, y, center_x, center_y, radius) {
            if (sqrt(Math.pow((x-center_x), 2) + Math.pow(y-center_y,2)) < radius) {
                return true;
            }
            return false;
        }

        // WIP, checks if ID occurs in the MAP at a certain DIRECTION and DISTANCE away from position (X, Y)
        function checkSelfCollision(x, y, distance, direction, map, id) {
            FOV = PI
            distance += 4
            
            for (let radian=direction-FOV/2; radian <= direction-FOV/2; radian+= PI/4) {
                proposed_x = Math.floor(x+Math.cos(radian)*distance)
                proposed_y = Math.floor(y+Math.sin(radian)*distance)

                if (proposed_y >= 0 && proposed_y < map.length && proposed_x >= 0 && proposed_x < map[0].length) {
                    if (map[proposed_y][proposed_x] == id) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Draws a square of a certain RADIUS at a position (X, Y) in specified MAP by setting the grid to a VALUE
        function drawToMap(x, y, value, radius = 1, map=drawn_map) {
            for (let x_off = -radius; x_off <= radius; x_off++) {
                for (let y_off = -radius; y_off <= radius; y_off++) {
                    if (y + y_off >= 0 && y + y_off < map.length && x + x_off >= 0 && x + x_off < map[0].length) {
                        map[y + y_off][x + x_off] = value;
                    }
                }
            }
        }

        // Where worker is generates lists of curves
        function getWorker() {
            var blob = new Blob([
                document.querySelector(curve_types[curve_type_index]).textContent
            ], { type: "text/javascript" })

            // Note: window.webkitURL.createObjectURL() in Chrome 10+.
            w = new Worker(window.URL.createObjectURL(blob));
            w.onmessage = function (e) {
                curves = e.data.curves;
                curves_made_before = e.data.curves_made_before;
                for (let n = 0; n < curves.length; n++) {
                    points = curves[n];
                    stroke_width = Math.floor(lerp(min_thickness, max_thickness + 1, random()));
                    strokeWeight(stroke_width);
                    color = chosen_colors[floor(random() * chosen_colors.length)]
                    stroke(color.hue, color.saturation, color.lightness);

                    last_point_x = -1000;
                    last_point_y = -1000;

                    beginShape();
                    var continue_curve = true;
                    for (let i = 0; (i < points.length && continue_curve); i++) {
                        if (i > 0) {
                            if (abs(Math.floor(points[i].x) - Math.floor(last_point_x)) > .0001 || abs(Math.floor(points[i].y) - Math.floor(last_point_y)) > .0001) {
                                curveVertex(Math.round(points[i].x*1000)/1000,Math.round(points[i].y*1000)/1000);
                                last_point_x = points[i].x;
                                last_point_y = points[i].y;
                            } 
                        } else {
                            curveVertex(points[i].x,points[i].y);
                            last_point_x = points[i].x;
                            last_point_y = points[i].y;
                        }
                        
                        // COLLISIONS WITH OTHER CURVES ---------------------------------------------------------------------------------------------
                        if (collision_removal) {    
                            // SAME COLOR CAN INTERSECT (SAME COLOR CURVES DO NOT KILL)
                            if (same_color_allowed) {
                                if (checkProximity(Math.floor(points[i].x - left_x), Math.floor(points[i].y - top_y), stroke_width + stroke_spacing, color, color_map)) {
                                    continue_curve = false;
                                } else {
                                    drawToMap(Math.floor(points[i].x - left_x), Math.floor(points[i].y - top_y), color, Math.floor(stroke_width / 2), color_map);
                                }
                            } else { // IF SAME COLOR CAN'T INTERSECT (ALL OTHER CURVES KILL)
                                if (checkProximity(Math.floor(points[i].x - left_x), Math.floor(points[i].y - top_y), stroke_width + stroke_spacing, curves_made_before + 1 + n, drawn_map)) {
                                    continue_curve = false;
                                }
                            }
                        }

                        // COLLIDING WITH THE SAME CURVE (WIP) --------------------------------------------------------------------------------------
                        if (i > 0 && self_collision_removal) {
                            if (checkSelfCollision(Math.floor(points[i].x - left_x), Math.floor(points[i].y - top_y), Math.floor((stroke_width + stroke_spacing)/2), angleFromXY(points[i].x-points[i-1].x, points[i].y-points[i-1].y), drawn_map, curves_made_before + 1 + n)) {
                                continue_curve = false;
                            }
                        }
                        
                        // COLLIDING WITH THE CENTER ------------------------------------------------------------------------------------------------
                        if (center_destruction) {
                            if (checkCenterCollision(points[i].x, points[i].y, width / 2, height / 2, distance_to_center)) {
                                continue_curve = false;
                            }
                        }

                        // DRAWING TO THE MAP IF NECESSARY ------------------------------------------------------------------------------------------
                        if (continue_curve && (self_collision_removal || (collision_removal && !(same_color_allowed)))) {
                            drawToMap(Math.floor(points[i].x - left_x), Math.floor(points[i].y - top_y), curves_made_before + 1 + n, Math.floor(stroke_width / 2), drawn_map);
                        }

                        // END COLLISION DETECTION

                        // If curve was killed and is long enough, draw it
                        if (!continue_curve && i>min_length) {
                            endShape();
                        }
                    }
                    // If curve died naturally, draw it
                    if (continue_curve) {
                        endShape();
                    }
                    
                    
                }
                // Kill worker when done drawing
                w.terminate();

                workers_complete += 1
                 
                if (workers_complete == total_workers-1 && save_and_restart) {
                    saveCanvas('curve', 'jpg');
                    drawings_made++;

                    if (save_data) {
                        drawing_data.push("drawn");
                    }

                    if (drawings_made < total_drawings) {
                        setupCustom();
                        draw();
                    } else if (save_data) {
                        var a = document.createElement("a");
                        a.href = window.URL.createObjectURL(new Blob([drawing_data.join("\n")], {type: "text/plain"}));
                        a.download = "demo.txt";
                        a.click()
                    }
                }
            };
            return w;
        }

        function angleFromXY(x, y) {
            if (x == 0) {
                if (y >= 0) {
                    return PI / 2;
                } else {
                    return 3 * PI / 2;
                }
            }

            theta = (Math.atan(y / x)) + 2 * PI;
            if (x < 0) {
                theta += PI;
            }
            return theta;
        }

        function findWhiteSpace(radius, max_tries) {
            row = 0;
            col = 0;

            found = false;
            tries = 0;
            while (!found && tries < max_tries) {
                tries += 1
                row = Math.floor(random() * drawn_map.length);
                col = Math.floor(random() * drawn_map[0].length);

                found = true;
                for (let row_off = -radius; row_off <= radius && found; row_off++) {
                    for (let col_off = -radius; col_off <= radius && found; col_off++) {
                        if (row + row_off >= 0 && row + row_off < drawn_map.length && col + col_off >= 0 && col + col_off < drawn_map[0].length) {
                            if (drawn_map[row + row_off][col + col_off] != 0) {
                                found = false;
                            }
                        }
                    }
                }
            }


            return [row * resolution, col * resolution]
        }

        function randomCoordinates() {
            var x = random() * width * ((1 + (decimal_overhang * 2))) - width * (decimal_overhang);
            var y = random() * height * ((1 + (decimal_overhang * 2))) - height * (decimal_overhang);

            return [x, y];
        }

        function getStartCoordinates(curves_made, curves) {
            curves_per_row = Math.floor(sqrt(curves));
            col_width = (width + 2 * width * decimal_overhang) / curves_per_row;
            row_height = (height + 2 * height * decimal_overhang) / curves_per_row;
            col = Math.floor(curves_made / curves_per_row);
            row = curves_made % curves_per_row;

            var x = col * col_width + left_x + Math.floor(random() * col_width - col_width / 3);
            var y = row * row_height + top_y + Math.floor(random() * row_height - col_width / 3);

            return [x, y];
        }
    </script>
</body>
</html>