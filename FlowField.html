<!DOCTYPE html>
<html>
<head>
    <title>Flow Field</title>
</head>
<body>
    <script src = "p5.js"></script>
    <script src = "sketch.js"></script>

    <!DOCTYPE html>
    <script id="multi_curve_worker" type="javascript/worker">
        self.onmessage = function(e) {
            [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before] = e.data.args;
            curves = [];
            for (var i=0; i<x_list.length; i++) {
                x = x_list[i];
                y = y_list[i];
                step_length = step_length_list[i];
                num_steps = num_steps_list[i];
                points = [];
                for (let n=0; n<num_steps; n++) {
                    x_offset = x - left_x;
                    y_offset = y - top_y;
                    column_index = Math.floor(x_offset / resolution);
                    row_index = Math.floor(y_offset / resolution);
                    points.push({'x' : x, 'y' : y});
                    if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows) {
                        grid_angle = grid[column_index][row_index];
                        x_step = step_length * Math.cos(grid_angle);
                        y_step = step_length * Math.sin(grid_angle);
                        x += x_step;
                        y += y_step;
                    } else {
                        break;
                    }
                }
                curves.push(points);
            }
            self.postMessage({"curves" : curves, "curves_made_before" : curves_made_before});
        };
    </script>
    <script type="text/javascript">
        var colors = [];
        var chosen_colors = [];

        var all_curves = [];

        var collision_removal = false;
        var drawn_map = [];
                
        var decimal_overhang = .1;

        var left_x;
        var right_x;
        var top_y;
        var bottom_y;

        var resolution;
        var num_columns;
        var num_rows;
        var grid;
        var default_angle;

        var curvesDrawn = 0;

        class Color {
            constructor(H, S, L) {
                this.hue = Math.floor(H);
                this.saturation = Math.floor(S);
                this.lightness = Math.floor(L);
            }

            get values() {
                return [this.hue, this.saturation, this.lightness]
            }
        }

        class MonochromaticSet {
            constructor(lDiff, lMin, lMax, startingColor=new Color(random()*360, random()*100+260, 720)) {
                this.colors = [];

                this.startingColor = startingColor;
                this.lDiff = lDiff;
                this.lMin = lMin;
                this.lMax = lMax;

                let hue = startingColor.hue;
                let sat = startingColor.saturation;
                let startL = (startingColor.lightness-lMin)%lDiff+lMin;
                for (let L=startL; L<lMax; L+=lDiff) {
                    this.colors.push(new Color(hue, sat, L));
                }
            }

            createSecondary(lDiff=this.lDiff, lMin=this.lMin, lMax=this.lMax, hOff=30) {
                return new MonochromaticSet(lDiff, lMin, lMax, new Color((this.startingColor.hue+hOff)%360, this.startingColor.saturation, this.startingColor.lightness));
            }
        }

        function roundAngleTo(angle, multiple) {
            return round(angle/multiple)*multiple;
        }

        function checkProximity(x, y, radius, ignored) {
            for (let x_off=-radius; x_off<=radius; x_off++) {
                for (let y_off=-radius; y_off<=radius; y_off++) {
                    if (y+y_off >= 0 && y+y_off < drawn_map.length && x+x_off >= 0 && x+x_off<drawn_map[0].length) {
                        if (drawn_map[y+y_off][x+x_off] != ignored) {
                            console.log(x,y)
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Where worker is sent lists of curves
        function getWorker() {
            var blob = new Blob([
                document.querySelector('#multi_curve_worker').textContent
            ], { type: "text/javascript" })

            // Note: window.webkitURL.createObjectURL() in Chrome 10+.
            var w = new Worker(window.URL.createObjectURL(blob));
            w.onmessage = function(e) {
                curves = e.data.curves;
                curves_made_before = e.data.curves_made_before;
                
                for (let n=0; n<curves.length; n++) {
                    points = curves[n];
                    strokeWeight(int(random()*1)+2);
                    color = chosen_colors[floor(random()*chosen_colors.length)]
                    stroke(color.hue, color.saturation, color.lightness);
                    
                    beginShape();
                    curveVertex(points[0].x, points[0].y);
                    end_curve = false;
                    for(let i=0; i<points.length || end_curve; i++) {
                        console.log(points);
                        curveVertex(points[i].x, points[i].y);
                        if (collision_removal && (Math.floor(points[i].y-top_y) >= 0 && Math.floor(points[i].y-top_y) < drawn_map.length && Math.floor(points[i].x-left_x) >= 0 && Math.floor(points[i].x-left_x) < drawn_map[0].length)) {
                            if (checkProximity(Math.floor(points[i].x-left_x), Math.floor(points[i].y-top_y), 100, curves_made_before+1+n)) { //} drawn_map[Math.floor(points[i].y-top_y)][Math.floor(points[i].x-left_x)] > curves_made_before+1+n) {
                                endShape();
                                end_curve = true;
                            } else {
                                drawn_map[Math.floor(points[i].y-top_y)][Math.floor(points[i].x-left_x)] = curves_made_before+1+n;
                            }

                            
                        }
                    }
                    endShape();
                }
                w.terminate();
            };
            return w;
        }


        function setup() {
            createCanvas(800, 800);

            colorMode(HSL, 360);

            colors.push(new MonochromaticSet(12, 0, 360))
            for (let i=0; i<11; i++) {
                colors.push(colors[colors.length-1].createSecondary())
            }

            var sets = 3;
            var min_off_set;
            var max_off_set;

            var colors_per_set = 4;
            var min_off_color = 1;
            var max_off_color = 3;

            var set_index = 2;
            for (let set=0; set<sets; set++) {
                var set_list = [];
                var color_index = 6;
                for (let color=0; color<colors_per_set; color++) {
                    chosen_colors.push(colors[set_index].colors[color_index]);
                    color_index += 2;
                }
                set_index += 2;
            }

            left_x = Math.floor(width * -(decimal_overhang));
            right_x = Math.floor(width * (1+(decimal_overhang)));
            top_y = Math.floor(height * -(decimal_overhang));
            bottom_y = Math.floor(height * (1+(decimal_overhang)));

            for (let row=0; row<Math.floor(bottom_y-top_y); row++) {
                var row_list = [];
                for (let col=0; col<Math.floor(right_x-left_x); col++) {
                    row_list.push(0);
                }
                drawn_map.push(row_list);
            }

            resolution = Math.floor(width * 0.01);
            num_columns = (right_x - left_x) / resolution;
            num_rows = (bottom_y - top_y) / resolution;
            grid = [];
            for (let i=0; i<num_columns; i++) {
                grid.push([]);
            }
            default_angle = PI * 0.25;

            for (let col=0; col<num_columns; col++) {
                for (let row=0; row<num_rows; row++) {
                    grid[col][row] = default_angle;
                }
            }

            for (let row=0; row<num_rows; row++) {    
                for (let col=0; col<num_columns; col++) {
                    // Processing's noise() works best when the step between
                    // points is approximately 0.005, so scale down to that
                    scaled_x = col * 0.015
                    scaled_y = row * 0.015
                    // translate the noise value to an angle (betwen 0 and 2 * PI)
                    angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2 * PI);
                    //angle = roundAngleTo(angle, PI/4);
                    //angle = random()*100/50*PI;
                    grid[col][row] = angle;
                }
            }
        }


        function getStartCoordinates(curves_made, curves) {
            //var x = random()*width*((1+(decimal_overhang*2)))-width*(decimal_overhang);
            //var y = random()*height*((1+(decimal_overhang*2)))-height*(decimal_overhang);
            
            curves_per_row = Math.floor(sqrt(curves));
            col_width = (width+2*width*decimal_overhang)/curves_per_row;
            row_height = (height+2*height*decimal_overhang)/curves_per_row;
            col = Math.floor(curves_made/curves_per_row);
            row = curves_made % curves_per_row;

            var x = col*col_width+left_x    +    Math.floor(random()*col_width-col_width/3);
            var y = row*row_height+top_y    +    Math.floor(random()*row_height-col_width/3);

            return [x, y];
        }

        function draw() {
            //translate(-width/2, -height/2, -100);
            background(0);
            noFill();
            noLoop();

            var total_workers = 450;

            var curves = 100;
            var curves_made = 0;
            var curves_made_before = 0;

            curve_per_worker = int(curves/total_workers);
            for (let i=0; i<min(total_workers, curves); i+=1) {
                w = getWorker();
                curves_for_this_worker = curve_per_worker;
                if (i < curves%total_workers) {
                    curves_for_this_worker++;
                }

                x_list = [];
                y_list = [];
                step_length_list = [];
                num_steps_list = [];

                curves_made_before = curves_made;

                for (let j=0; j<curves_for_this_worker; j+=1) {
                    [x, y] = getStartCoordinates(curves_made, curves);
                    
                    x_list.push(x);
                    y_list.push(y);

                    var step_length = 1;
                    step_length_list.push(step_length);
                    var num_steps = Math.floor((random()*100+200));
                    num_steps_list.push(num_steps);
                    curves_made += 1;
                    all_curves.push([]);
                }
                w.postMessage({"args" : [x_list, y_list, grid, left_x, top_y, resolution, step_length_list, num_steps_list, num_columns, num_rows, curves_made_before]});
            }
        }
    </script>
</body>
</html>