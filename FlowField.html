<!DOCTYPE html>
<html>
<head>
    <title>Flow Field</title>
</head>
<body>
    <script src = "p5.js"></script>
    <script src = "sketch.js"></script>

    <!DOCTYPE html>
    <script id="worker1" type="javascript/worker">
    // This script won't be parsed by JS engines because its type is javascript/worker.
    self.onmessage = function(e) {
        [x, y, grid, left_x, top_y, resolution, step_length, num_steps, num_columns, num_rows] = e.data.args;
        points = [];
        for (let n=0; n<num_steps; n++) {
            x_offset = x - left_x;
            y_offset = y - top_y;
            column_index = parseInt(x_offset / resolution);
            row_index = parseInt(y_offset / resolution);
            points.push({'x' : x, 'y' : y});
            if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows) {
                grid_angle = grid[column_index][row_index];
                x_step = step_length * Math.cos(grid_angle);
                y_step = step_length * Math.sin(grid_angle);
                x += x_step;
                y += y_step;
            } else {
                break;
            }
        }
        self.postMessage(points);
    };
    // Rest of your worker code goes here.
    </script>
    <script type="text/javascript">
        var left_x;
        var right_x;
        var top_y;
        var bottom_y;

        var resolution;
        var num_columns;
        var num_rows;
        var grid;
        var default_angle;

        function roundAngleTo(angle, multiple) {
            return round(angle/multiple)*multiple;
        }

        function checkProximity(x, y) {

        }

        function setup() {
            createCanvas(800, 800);

            left_x = parseInt(width * -0.2);
            right_x = parseInt(width * 1.2);
            top_y = parseInt(height * -0.2);
            bottom_y = parseInt(height * 1.2);

            resolution = parseInt(width * 0.01);
            num_columns = (right_x - left_x) / resolution;
            num_rows = (bottom_y - top_y) / resolution;
            grid = [];
            for (let i=0; i<num_columns; i++) {
                grid.push([]);
            }
            default_angle = PI * 0.25;

            for (let col=0; col<num_columns; col++) {
                for (let row=0; row<num_rows; row++) {
                    grid[col][row] = default_angle;
                }
            }

            for (let col=0; col<num_columns; col++) {
                for (let row=0; row<num_rows; row++) {
                    // Processing's noise() works best when the step between
                    // points is approximately 0.005, so scale down to that
                    scaled_x = col * 0.05
                    scaled_y = row * 0.05
                    // translate the noise value to an angle (betwen 0 and 2 * PI)
                    angle = map(noise(scaled_x, scaled_y), 0, 1, 0, 2 * PI);
                    //angle = roundAngleTo(angle, PI/4);
                    //angle = random()*100/50*PI
                    grid[col][row] = angle;
                }
            }
        }

        function startWorker(x, y, step_length, num_steps) {
            var blob = new Blob([
                document.querySelector('#worker1').textContent
            ], { type: "text/javascript" })

            // Note: window.webkitURL.createObjectURL() in Chrome 10+.
            var w = new Worker(window.URL.createObjectURL(blob));
            w.onmessage = function(e) {
                points = e.data;
                strokeWeight(1)
                stroke(random()*255,random()*255,random()*255);
                beginShape();
                curveVertex(e.data[0].x, e.data[0].y);
                for(let i=0; i<e.data.length; i++) {
                    curveVertex(e.data[i].x, e.data[i].y);
                }
                curveVertex(e.data[e.data.length-1].x, e.data[event.data.length-1].y);
                endShape();
                w.terminate();
            };
            w.postMessage({"args" : [x, y, grid, left_x, top_y, resolution, step_length, num_steps, num_columns, num_rows]})
        }

        function draw() {
            //translate(-width/2, -height/2, -100);
            background(0);
            noFill();
            noLoop();

            var curves = 500;
            //translate(-width*.5, -height*.5, -500);

            for (let i=0; i<curves; i+=1) {
                var x = random()*width*1.4-width*.2;
                var y = random()*height*1.4-height*.2;

                let step_length = 10;
                let num_steps = parseInt((random(100)+100));
                
                startWorker(x, y, step_length, num_steps);

                // beginShape();
                // curveVertex(x, y);
                // for (let n=0; n<num_steps; n++) {
                //     x_offset = x - left_x;
                //     y_offset = y - top_y;
                //     column_index = parseInt(x_offset / resolution);
                //     row_index = parseInt(y_offset / resolution);
                //     //if checkProximity(x,y) {
                //         curveVertex(x,y);
                //     //}
                //     if (column_index>=0 && row_index>=0 && column_index<num_columns && row_index<num_rows) {
                //         grid_angle = grid[column_index][row_index];
                //         x_step = step_length * Math.cos(grid_angle);
                //         y_step = step_length * Math.sin(grid_angle);
                //         x += x_step;
                //         y += y_step;
                //     } else {
                //         break;
                //     }
                // }
                // curveVertex(x, y);
                // curveVertex(x, y);
                // endShape();
            }
        }
        
    </script>
</body>
</html>

